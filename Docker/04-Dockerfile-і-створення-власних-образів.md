# 04. Dockerfile і створення власних образів

Dockerfile - це текстовий файл з інструкціями, які описують, як створити Docker-образ. У цьому розділі ми розглянемо структуру Dockerfile та процес створення власних образів.

## Структура Dockerfile

Dockerfile складається з серії інструкцій, кожна з яких створює новий шар в образі:

### Основні інструкції

| Інструкція     | Опис                                            |
| -------------- | ----------------------------------------------- |
| `FROM`         | Базовий образ, від якого створюється новий      |
| `LABEL`        | Метадані образу (автор, версія, опис)           |
| `ENV`          | Встановлення змінних середовища                 |
| `WORKDIR`      | Встановлення робочої директорії                 |
| `COPY` / `ADD` | Копіювання файлів з хоста в образ               |
| `RUN`          | Виконання команд під час побудови образу        |
| `EXPOSE`       | Документування портів, які слухає контейнер     |
| `VOLUME`       | Створення точки монтування для тому             |
| `USER`         | Встановлення користувача для запуску команд     |
| `CMD`          | Команда за замовчуванням при запуску контейнера |
| `ENTRYPOINT`   | Головна точка входу для контейнера              |

### Приклад базового Dockerfile

```dockerfile
# Базовий образ
FROM node:14-alpine

# Метадані
LABEL maintainer="your.email@example.com"
LABEL version="1.0"
LABEL description="Simple Node.js application"

# Змінні середовища
ENV NODE_ENV=production
ENV PORT=3000

# Робоча директорія
WORKDIR /app

# Копіювання файлів залежностей
COPY package*.json ./

# Встановлення залежностей
RUN npm install --production

# Копіювання решти файлів проекту
COPY . .

# Документування портів
EXPOSE 3000

# Користувач для запуску програми
USER node

# Команда запуску
CMD ["node", "index.js"]
```

> **Важливо!** Порядок інструкцій у Dockerfile має значення для оптимізації процесу кешування шарів. Розміщуйте інструкції, які рідше змінюються, ближче до початку файлу.

## Деталі основних інструкцій

### FROM

```dockerfile
FROM <image>[:<tag>] [AS <name>]
```

-   Це обов'язкова перша інструкція в Dockerfile
-   Рекомендується використовувати офіційні образи
-   Можна використовувати варіант `scratch` для створення мінімального образу

Приклади:

```dockerfile
FROM ubuntu:20.04
FROM python:3.9-slim AS builder
FROM scratch
```

### COPY vs ADD

```dockerfile
COPY <src>... <dest>
ADD <src>... <dest>
```

-   `COPY` просто копіює файли і директорії
-   `ADD` має додаткові функції:
    -   Розпаковує архіви
    -   Може завантажувати файли з URL

> **Порада:** Надавайте перевагу `COPY` для простого копіювання файлів, оскільки це більш передбачувано. Використовуйте `ADD` тільки коли вам потрібні його специфічні функції.

### RUN

```dockerfile
RUN <command>
RUN ["executable", "param1", "param2"]
```

-   Виконує команди в процесі побудови образу
-   Кожна інструкція `RUN` створює новий шар в образі

Приклад оптимізованої інструкції RUN:

```dockerfile
RUN apt-get update && \
    apt-get install -y --no-install-recommends \
        package1 \
        package2 \
        package3 && \
    apt-get clean && \
    rm -rf /var/lib/apt/lists/*
```

### CMD vs ENTRYPOINT

```dockerfile
CMD ["executable", "param1", "param2"]
ENTRYPOINT ["executable", "param1", "param2"]
```

-   `CMD` - команда за замовчуванням, яка виконується при запуску контейнера
-   `ENTRYPOINT` - фіксована команда, яка виконується при запуску контейнера
-   Параметри командного рядка, передані `docker run`, замінюють `CMD`, але додаються до `ENTRYPOINT`

Типова комбінація:

```dockerfile
ENTRYPOINT ["nginx"]
CMD ["-g", "daemon off;"]
```

Це дозволяє запускати контейнер з командою `docker run my-nginx` (використовуючи параметри за замовчуванням) або з власними параметрами: `docker run my-nginx -c /custom-nginx.conf`.

## Створення кастомного образу (docker build)

Команда `docker build` використовується для створення образу з Dockerfile.

Синтаксис:

```bash
docker build [OPTIONS] PATH | URL | -
```

Основні опції:

-   `-t, --tag` - задання імені та тегу образу
-   `-f, --file` - шлях до Dockerfile (якщо він має нестандартне ім'я або розташування)
-   `--no-cache` - примусова повна перебудова без використання кешу
-   `--build-arg` - передача змінних сборки, оголошених через `ARG` в Dockerfile

### Приклад процесу створення образу

1. Створіть директорію для проекту і перейдіть до неї:

```bash
mkdir my-docker-app
cd my-docker-app
```

2. Створіть простий Node.js додаток:

`package.json`:

```json
{
    "name": "my-docker-app",
    "version": "1.0.0",
    "main": "index.js",
    "dependencies": {
        "express": "^4.17.1"
    }
}
```

`index.js`:

```javascript
const express = require("express");
const app = express();
const PORT = process.env.PORT || 3000;

app.get("/", (req, res) => {
    res.send("Hello from Docker!");
});

app.listen(PORT, () => {
    console.log(`Server running on port ${PORT}`);
});
```

3. Створіть Dockerfile:

```dockerfile
FROM node:14-alpine

WORKDIR /app

COPY package*.json ./
RUN npm install

COPY . .

EXPOSE 3000

CMD ["node", "index.js"]
```

4. Створіть образ:

```bash
docker build -t my-node-app:1.0 .
```

5. Перевірте, що образ успішно створено:

```bash
docker images
```

6. Запустіть контейнер з цього образу:

```bash
docker run -d -p 3000:3000 --name my-app my-node-app:1.0
```

7. Перевірте доступність додатку у браузері за адресою `http://localhost:3000` або через curl:

```bash
curl http://localhost:3000
```

## Багатоетапні збірки

Багатоетапні збірки дозволяють створювати більш оптимізовані образи, використовуючи проміжні контейнери для збірки.

Переваги:

-   Зменшення розміру кінцевого образу
-   Розділення залежностей для збірки та запуску
-   Підвищення безпеки (менше вразливих компонентів)

### Приклад багатоетапної збірки для Go-додатку:

```dockerfile
# Етап збірки
FROM golang:1.17 AS builder

WORKDIR /app

COPY go.mod go.sum ./
RUN go mod download

COPY . .
RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o app .

# Етап запуску
FROM alpine:3.14

RUN apk --no-cache add ca-certificates

WORKDIR /root/

# Копіювання тільки бінарного файлу з попереднього етапу
COPY --from=builder /app/app .

EXPOSE 8080

CMD ["./app"]
```

### Приклад багатоетапної збірки для Node.js:

```dockerfile
# Етап збірки
FROM node:14 AS builder

WORKDIR /app

COPY package*.json ./
RUN npm install

COPY . .
RUN npm run build

# Етап запуску
FROM node:14-alpine

WORKDIR /app

COPY --from=builder /app/dist ./dist
COPY --from=builder /app/node_modules ./node_modules
COPY --from=builder /app/package.json .

EXPOSE 3000

CMD ["npm", "start"]
```

## Типові проблеми та їх вирішення

1. **Проблема**: Образ занадто великий.
   **Рішення**:

    - Використовуйте легші базові образи (Alpine)
    - Застосовуйте багатоетапні збірки
    - Очищуйте кеш після встановлення пакетів

2. **Проблема**: Повільна збірка через перевстановлення залежностей.
   **Рішення**:

    - Копіюйте тільки файли залежностей перед встановленням
    - Встановлюйте залежності в окремому шарі

3. **Проблема**: Вразливості безпеки в образі.
   **Рішення**:

    - Використовуйте сканери вразливостей (Trivy, Clair)
    - Регулярно оновлюйте базові образи
    - Запускайте контейнер від непривілейованого користувача

4. **Проблема**: Dockerfile не працює на CI/CD.
   **Рішення**:
    - Переконайтеся, що всі шляхи відносні
    - Використовуйте `ARG` для змінних середовища
    - Документуйте всі залежності

## Найкращі практики

1. **Використовуйте конкретні теги базових образів** замість `latest` для забезпечення відтворюваності збірок.
2. **Групуйте команди `RUN`** за допомогою `&&` для зменшення кількості шарів.
3. **Розміщуйте найбільш сталі інструкції спочатку** для ефективного використання кешу.
4. **Використовуйте `.dockerignore`** для виключення непотрібних файлів (як `.gitignore`).
5. **Мінімізуйте кількість шарів** для зменшення розміру образу.
6. **Запускайте програми від непривілейованого користувача** для підвищення безпеки.
7. **Використовуйте багатоетапні збірки** для складних додатків.
8. **Ніколи не включайте секрети (паролі, ключі)** в образ, використовуйте змінні середовища або Docker secrets.
9. **Перевіряйте образи на вразливості** перед розгортанням.
10. **Налаштовуйте healthcheck** для моніторингу стану контейнера.

```dockerfile
# Приклад healthcheck
HEALTHCHECK --interval=30s --timeout=3s \
  CMD curl -f http://localhost/ || exit 1
```
