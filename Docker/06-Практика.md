# 06. Практика з Docker

У цьому розділі ми застосуємо отримані знання на практиці, розгорнувши реальні додатки за допомогою Docker. Ми розглянемо два сценарії: запуск простого веб-додатку в окремому контейнері та налаштування більш складного середовища з використанням Docker Compose.

## Запуск простого веб-додатку в контейнері

Створимо простий веб-додаток на Node.js і розгорнемо його в контейнері.

### Крок 1: Створення структури проекту

```bash
mkdir simple-web-app
cd simple-web-app
```

### Крок 2: Створення файлів додатку

`package.json`:

```json
{
    "name": "simple-web-app",
    "version": "1.0.0",
    "description": "A simple web application for Docker demo",
    "main": "app.js",
    "scripts": {
        "start": "node app.js"
    },
    "dependencies": {
        "express": "^4.18.2"
    }
}
```

`app.js`:

```javascript
const express = require("express");
const app = express();
const PORT = process.env.PORT || 3000;

app.get("/", (req, res) => {
    res.send(`
    <h1>Hello from Docker!</h1>
    <p>This is a simple web application running in a Docker container.</p>
    <p>Server time: ${new Date().toLocaleString()}</p>
    <p>Hostname: ${process.env.HOSTNAME || "unknown"}</p>
  `);
});

app.listen(PORT, () => {
    console.log(`Server running on port ${PORT}`);
});
```

### Крок 3: Створення Dockerfile

```dockerfile
FROM node:16-alpine

WORKDIR /app

COPY package*.json ./
RUN npm install

COPY . .

EXPOSE 3000

CMD ["npm", "start"]
```

### Крок 4: Створення .dockerignore

```
node_modules
npm-debug.log
Dockerfile
.dockerignore
.git
.gitignore
```

### Крок 5: Побудова образу

```bash
docker build -t simple-web-app:1.0 .
```

### Крок 6: Запуск контейнера

```bash
docker run -d -p 3000:3000 --name my-web-app simple-web-app:1.0
```

### Крок 7: Перевірка роботи

Відкрийте браузер і перейдіть за адресою http://localhost:3000

### Крок 8: Перегляд логів контейнера

```bash
docker logs my-web-app
```

### Крок 9: Зупинка та видалення контейнера

```bash
docker stop my-web-app
docker rm my-web-app
```

> **Порада:** Використовуйте прапорець `--rm` при запуску контейнера для автоматичного видалення після зупинки: `docker run --rm -d -p 3000:3000 --name my-web-app simple-web-app:1.0`

## Підняття nginx + postgres + app через Docker Compose

Тепер створимо більш складне середовище: веб-додаток з базою даних Postgres і Nginx в якості проксі-сервера.

### Крок 1: Створення структури проекту

```bash
mkdir full-stack-demo
cd full-stack-demo
mkdir -p app nginx
```

### Крок 2: Створення додатку

`app/package.json`:

```json
{
    "name": "full-stack-demo",
    "version": "1.0.0",
    "description": "Full stack demo with Docker Compose",
    "main": "server.js",
    "scripts": {
        "start": "node server.js"
    },
    "dependencies": {
        "express": "^4.18.2",
        "pg": "^8.11.3",
        "dotenv": "^16.3.1"
    }
}
```

`app/server.js`:

```javascript
const express = require("express");
const { Pool } = require("pg");
const app = express();
const PORT = process.env.PORT || 3000;

// Налаштування підключення до Postgres
const pool = new Pool({
    user: process.env.DB_USER,
    host: process.env.DB_HOST,
    database: process.env.DB_NAME,
    password: process.env.DB_PASSWORD,
    port: process.env.DB_PORT || 5432,
});

// Ініціалізація таблиці
pool.query(
    `
  CREATE TABLE IF NOT EXISTS visits (
    id SERIAL PRIMARY KEY,
    timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP
  )
`
).catch((err) => console.error("Error creating table:", err));

app.get("/", async (req, res) => {
    try {
        // Записуємо кожне відвідування
        await pool.query(
            "INSERT INTO visits(timestamp) VALUES(CURRENT_TIMESTAMP)"
        );

        // Отримуємо кількість відвідувань
        const result = await pool.query("SELECT COUNT(*) FROM visits");
        const visitsCount = result.rows[0].count;

        res.send(`
      <h1>Full Stack Docker Demo</h1>
      <p>This page has been visited ${visitsCount} times.</p>
      <p>Server time: ${new Date().toLocaleString()}</p>
      <p>Hostname: ${process.env.HOSTNAME || "unknown"}</p>
    `);
    } catch (err) {
        console.error("Database error:", err);
        res.status(500).send("Database connection error");
    }
});

app.get("/health", (req, res) => {
    res.status(200).send("OK");
});

app.listen(PORT, () => {
    console.log(`Server running on port ${PORT}`);
});
```

`app/Dockerfile`:

```dockerfile
FROM node:16-alpine

WORKDIR /app

COPY package*.json ./
RUN npm install

COPY . .

EXPOSE 3000

CMD ["node", "server.js"]
```

### Крок 3: Налаштування Nginx

`nginx/nginx.conf`:

```nginx
worker_processes 1;

events {
    worker_connections 1024;
}

http {
    sendfile on;
    tcp_nopush on;
    tcp_nodelay on;
    keepalive_timeout 65;
    types_hash_max_size 2048;

    include /etc/nginx/mime.types;
    default_type application/octet-stream;

    server {
        listen 80;
        server_name localhost;

        location / {
            proxy_pass http://app:3000;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
        }

        # Для статичних файлів, якщо вони будуть
        location /static {
            alias /usr/share/nginx/html/static;
        }
    }
}
```

### Крок 4: Створення Docker Compose файлу

`docker-compose.yml`:

```yaml
version: "3.8"

services:
    app:
        build: ./app
        restart: always
        environment:
            - PORT=3000
            - DB_HOST=db
            - DB_USER=postgres
            - DB_NAME=postgres
            - DB_PASSWORD=postgres
            - DB_PORT=5432
        depends_on:
            - db
        healthcheck:
            test: ["CMD", "wget", "-qO-", "http://localhost:3000/health"]
            interval: 30s
            timeout: 10s
            retries: 3
            start_period: 10s

    nginx:
        image: nginx:alpine
        ports:
            - "80:80"
        volumes:
            - ./nginx/nginx.conf:/etc/nginx/nginx.conf:ro
            - ./static:/usr/share/nginx/html/static:ro
        depends_on:
            - app

    db:
        image: postgres:13-alpine
        volumes:
            - postgres_data:/var/lib/postgresql/data
        environment:
            - POSTGRES_USER=postgres
            - POSTGRES_PASSWORD=postgres
            - POSTGRES_DB=postgres
        healthcheck:
            test: ["CMD-SHELL", "pg_isready -U postgres"]
            interval: 10s
            timeout: 5s
            retries: 5

volumes:
    postgres_data:
```

### Крок 5: Створення директорії для статичних файлів

```bash
mkdir static
echo "<h1>Static content</h1>" > static/index.html
```

### Крок 6: Запуск середовища

```bash
docker-compose up -d
```

### Крок 7: Перевірка статусу

```bash
docker-compose ps
```

### Крок 8: Перевірка роботи додатку

Відкрийте браузер і перейдіть за адресою http://localhost

Для перевірки статичного контенту: http://localhost/static/

### Крок 9: Перегляд логів

```bash
# Логи всіх сервісів
docker-compose logs

# Логи окремого сервісу
docker-compose logs app
```

### Крок 10: Масштабування додатку

```bash
# Запуск кількох екземплярів сервісу app
docker-compose up -d --scale app=3
```

> **Важливо!** При масштабуванні сервісу `app` потрібно видалити налаштування фіксованих портів для цього сервісу з docker-compose.yml, інакше виникне конфлікт портів. Nginx автоматично розподілятиме запити між контейнерами.

### Крок 11: Зупинка та очищення

```bash
# Зупинка сервісів без видалення даних
docker-compose down

# Зупинка сервісів з видаленням томів
docker-compose down -v
```

## Типові проблеми та їх вирішення

### 1. Проблеми з'єднання між контейнерами

**Проблема**: Контейнер не може підключитися до іншого контейнера.

**Рішення**:

-   Переконайтеся, що використовуєте ім'я сервісу як хост (наприклад, `db` замість `localhost`)
-   Перевірте, чи знаходяться контейнери в одній мережі
-   Перевірте статус контейнерів: `docker-compose ps`
-   Перевірте логи: `docker-compose logs <service_name>`

### 2. Проблеми доступу до томів

**Проблема**: Дані не зберігаються в томі або контейнер не має доступу до файлів тому.

**Рішення**:

-   Перевірте правильність шляхів монтування
-   Перевірте права доступу до файлів та директорій
-   На Windows та macOS можуть бути обмеження доступу, які потрібно налаштувати в Docker Desktop

### 3. Конфлікти портів

**Проблема**: Сервіс не запускається через зайнятий порт.

**Рішення**:

-   Змініть порт на хості в налаштуваннях `ports`
-   Перевірте, чи не використовує цей порт інший процес: `netstat -tuln | grep <port>`

### 4. Помилки бази даних

**Проблема**: Додаток не може підключитися до бази даних.

**Рішення**:

-   Перевірте змінні середовища для підключення
-   Додайте затримку перед спробою підключення до бази даних
-   Використовуйте `depends_on` з `healthcheck` для правильної послідовності запуску

## Найкращі практики

1. **Використовуйте Docker Compose для розробки та тестування**, а Kubernetes або Docker Swarm для промислових середовищ.

2. **Створюйте окремі файли docker-compose для різних середовищ**:

    - `docker-compose.yml` - базова конфігурація
    - `docker-compose.override.yml` - налаштування для розробки (за замовчуванням)
    - `docker-compose.prod.yml` - налаштування для продакшну

3. **Використовуйте healthcheck для перевірки готовності сервісів**:

    ```yaml
    healthcheck:
        test: ["CMD", "curl", "-f", "http://localhost:3000/health"]
        interval: 30s
        timeout: 10s
        retries: 3
    ```

4. **Налаштуйте логування для всіх сервісів**:

    ```yaml
    logging:
        driver: "json-file"
        options:
            max-size: "10m"
            max-file: "3"
    ```

5. **Використовуйте змінні середовища для конфігурації** замість хардкодинга значень.

6. **Налаштуйте автоматичний перезапуск для критичних сервісів**:

    ```yaml
    restart: always # або on-failure, unless-stopped
    ```

7. **Обмежуйте ресурси для контейнерів**:

    ```yaml
    deploy:
        resources:
            limits:
                cpus: "0.5"
                memory: 512M
    ```

8. **Резервне копіювання даних**: регулярно створюйте резервні копії томів з даними.

9. **Документуйте процес запуску та зупинки** вашого середовища для інших розробників.

10. **Використовуйте профілі для запуску різних комбінацій сервісів**:
    ```yaml
    services:
        app:
            profiles: [app, all]
        monitoring:
            profiles: [monitoring, all]
    ```
    Запуск: `docker-compose --profile all up -d`
