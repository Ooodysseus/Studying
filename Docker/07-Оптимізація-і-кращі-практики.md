# 07. Оптимізація і кращі практики Docker

У цьому розділі ми розглянемо методи оптимізації роботи з Docker, включаючи управління об'ємами та мережами, зменшення розміру образів та забезпечення безпеки контейнерів.

## Менеджмент об'ємів і мереж

### Управління Docker-об'ємами

Docker-об'єми (volumes) - це механізм для збереження даних контейнерів, який забезпечує постійність даних і дозволяє легко спільно використовувати дані між контейнерами.

#### Типи збереження даних в Docker:

1. **Volumes** (об'єми) - найкращий спосіб персистентного збереження даних
2. **Bind mounts** (прив'язані монтування) - прив'язка директорії хоста до контейнера
3. **tmpfs mounts** (тимчасові монтування) - збереження тільки в пам'яті

#### Команди для роботи з об'ємами:

```bash
# Створення об'єму
docker volume create my_data

# Перегляд списку об'ємів
docker volume ls

# Перегляд детальної інформації про об'єм
docker volume inspect my_data

# Видалення невикористовуваних об'ємів
docker volume prune

# Видалення конкретного об'єму
docker volume rm my_data
```

#### Використання об'ємів при запуску контейнера:

```bash
# Використання іменованого об'єму
docker run -d --name db -v my_data:/var/lib/postgresql/data postgres:13

# Використання bind mount
docker run -d --name web -v $(pwd)/html:/usr/share/nginx/html nginx

# Використання тимчасового сховища
docker run -d --name cache --tmpfs /tmp redis
```

#### Стратегії бекапу даних:

1. **Використання команди docker cp**:

    ```bash
    # Копіювання даних з контейнера на хост
    docker cp db:/var/lib/postgresql/data ./backup
    ```

2. **Використання спеціального контейнера для бекапу**:

    ```bash
    # Запуск контейнера, який монтує той самий об'єм і виконує бекап
    docker run --rm -v my_data:/data -v $(pwd):/backup alpine tar czf /backup/data.tar.gz -C /data .
    ```

3. **Використання docker-compose**:
    ```yaml
    services:
        backup:
            image: alpine
            volumes:
                - my_data:/data
                - ./backups:/backups
            command: tar czf /backups/data-$(date +%Y%m%d).tar.gz -C /data .
    ```

> **Порада:** Регулярно робіть бекапи важливих даних і тестуйте процес відновлення з них.

### Управління Docker-мережами

Docker-мережі забезпечують ізольоване середовище комунікації між контейнерами та із зовнішнім світом.

#### Типи мереж:

1. **bridge** - стандартна мережа для контейнерів на одному хості
2. **host** - контейнер використовує мережевий стек хоста
3. **none** - відсутність мережевого з'єднання
4. **overlay** - мережа для контейнерів на різних хостах (для Swarm)
5. **macvlan** - призначення MAC-адреси контейнерам

#### Команди для роботи з мережами:

```bash
# Створення мережі
docker network create my_network

# Створення мережі з додатковими опціями
docker network create --driver bridge --subnet=172.18.0.0/16 --gateway=172.18.0.1 my_custom_network

# Перегляд списку мереж
docker network ls

# Перегляд детальної інформації про мережу
docker network inspect my_network

# Підключення контейнера до мережі
docker network connect my_network container_name

# Відключення контейнера від мережі
docker network disconnect my_network container_name

# Видалення мережі
docker network rm my_network

# Видалення невикористовуваних мереж
docker network prune
```

#### Конфігурація мереж у docker-compose:

```yaml
version: "3.8"

networks:
    frontend:
        driver: bridge
    backend:
        driver: bridge
        internal: true # Без доступу до інтернету

services:
    web:
        image: nginx
        networks:
            - frontend

    api:
        image: my-api
        networks:
            - frontend
            - backend

    db:
        image: postgres
        networks:
            - backend
```

> **Важливо!** Використовуйте внутрішні мережі для сервісів, яким не потрібен доступ до зовнішнього світу (наприклад, бази даних), щоб підвищити безпеку.

## Зменшення розміру образів

Менші за розміром образи мають ряд переваг:

-   Швидше завантаження та розгортання
-   Менше споживання дискового простору
-   Менша поверхня для атак

### Стратегії оптимізації розміру образів:

#### 1. Використання легких базових образів

```dockerfile
# Замість
FROM ubuntu:20.04  # ~70MB

# Використовуйте
FROM alpine:3.16   # ~5MB
```

Порівняння популярних базових образів:

-   `ubuntu`: ~70MB
-   `debian:slim`: ~30MB
-   `alpine`: ~5MB
-   `busybox`: ~1.2MB
-   `scratch`: 0MB (порожній образ)

#### 2. Багатоетапні збірки

```dockerfile
# Етап збірки
FROM node:16 AS builder
WORKDIR /app
COPY package*.json ./
RUN npm install
COPY . .
RUN npm run build

# Етап запуску
FROM nginx:alpine
COPY --from=builder /app/build /usr/share/nginx/html
EXPOSE 80
CMD ["nginx", "-g", "daemon off;"]
```

#### 3. Об'єднання команд RUN

```dockerfile
# Погано: кожна команда RUN створює новий шар
RUN apt-get update
RUN apt-get install -y package1
RUN apt-get install -y package2
RUN apt-get clean

# Добре: об'єднання команд в один шар
RUN apt-get update && \
    apt-get install -y \
        package1 \
        package2 && \
    apt-get clean && \
    rm -rf /var/lib/apt/lists/*
```

#### 4. Видалення тимчасових файлів

```dockerfile
# Приклад для Python
RUN pip install --no-cache-dir -r requirements.txt

# Приклад для Node.js
RUN npm install && \
    npm cache clean --force

# Приклад для Alpine
RUN apk add --no-cache package1 package2
```

#### 5. Використання .dockerignore

Створіть файл `.dockerignore` для виключення непотрібних файлів:

```
node_modules
npm-debug.log
Dockerfile
.dockerignore
.git
.gitignore
README.md
tests
docs
*.md
```

#### 6. Видалення пакетних менеджерів та інструментів збірки

```dockerfile
FROM debian:slim

# Встановлення пакетів і одразу видалення кешу пакетного менеджера
RUN apt-get update && \
    apt-get install -y --no-install-recommends \
        package1 \
        package2 && \
    apt-get clean && \
    rm -rf /var/lib/apt/lists/*

# Для Node.js образів: видалення devDependencies після збірки
RUN npm install && \
    npm run build && \
    npm prune --production
```

### Аналіз розміру образу

```bash
# Перегляд розміру образів
docker images

# Аналіз шарів образу
docker history my-image:tag

# Використання спеціальних інструментів
docker run --rm -v /var/run/docker.sock:/var/run/docker.sock wagoodman/dive:latest my-image:tag
```

> **Порада:** Інструмент `dive` дозволяє аналізувати кожен шар образу і знаходити файли, які займають найбільше місця.

## Безпека контейнерів

Забезпечення безпеки Docker-контейнерів - критично важливий аспект при використанні Docker у продакшн середовищі.

### Найкращі практики для забезпечення безпеки:

#### 1. Використання непривілейованих користувачів

```dockerfile
# Створення непривілейованого користувача
RUN addgroup -S appgroup && adduser -S appuser -G appgroup

# Зміна власника файлів
COPY --chown=appuser:appgroup . .

# Перемикання на непривілейованого користувача
USER appuser

# Запуск програми
CMD ["./app"]
```

#### 2. Сканування вразливостей

Використовуйте інструменти для сканування образів на наявність вразливостей:

```bash
# Приклад з Trivy
docker run --rm -v /var/run/docker.sock:/var/run/docker.sock aquasec/trivy image my-image:tag

# Приклад з Clair
docker run --rm -p 5432:5432 -p 6060:6060 quay.io/coreos/clair
```

Інтеграція сканування в CI/CD pipeline:

```yaml
# Приклад для GitLab CI
security_scan:
    image: aquasec/trivy
    script:
        - trivy image my-image:$CI_COMMIT_SHORT_SHA
```

#### 3. Встановлення ресурсних обмежень

```bash
# Обмеження пам'яті та CPU
docker run -d --name app \
  --memory="512m" \
  --memory-swap="1g" \
  --cpus="1.0" \
  my-image
```

У docker-compose:

```yaml
services:
    app:
        image: my-image
        deploy:
            resources:
                limits:
                    cpus: "1.0"
                    memory: 512M
```

#### 4. Використання readonly файлової системи

```bash
# Монтування файлової системи в режимі тільки для читання
docker run --read-only -v /tmp:/tmp my-image
```

#### 5. Застосування security-first налаштувань

```bash
# Вимкнення привілейованого режиму
docker run --security-opt=no-new-privileges my-image

# Використання seccomp профілів
docker run --security-opt seccomp=/path/to/seccomp.json my-image

# Використання AppArmor профілів
docker run --security-opt apparmor=docker-default my-image
```

#### 6. Регулярне оновлення образів

```bash
# Перевірка наявності оновлень
docker pull nginx:latest

# Автоматичне оновлення контейнерів (з Watchtower)
docker run -d \
  --name watchtower \
  -v /var/run/docker.sock:/var/run/docker.sock \
  containrrr/watchtower
```

#### 7. Використання мережевої сегментації

```yaml
# Приклад в docker-compose
services:
    web:
        networks:
            - frontend

    api:
        networks:
            - frontend
            - backend

    db:
        networks:
            - backend

networks:
    frontend:
    backend:
        internal: true # Без зовнішнього доступу
```

#### 8. Уникнення секретів у Dockerfile та образах

```dockerfile
# Погано: секрети в образі
ENV API_KEY="secret123"

# Краще: використання змінних середовища при запуску
# docker run -e API_KEY="secret123" my-image
```

Безпечне передавання секретів:

```bash
# Використання Docker secrets (для Swarm)
docker secret create my_secret ./secret.txt
docker service create --secret my_secret my-image

# Або через файли змінних середовища
docker run --env-file ./.env my-image
```

#### 9. Моніторинг та логування

```bash
# Налаштування логування
docker run --log-driver=syslog --log-opt syslog-address=udp://logserver:514 my-image

# Використання інструментів моніторингу
docker run -d --name cadvisor \
  -v /:/rootfs:ro \
  -v /var/run:/var/run:ro \
  -v /sys:/sys:ro \
  -v /var/lib/docker/:/var/lib/docker:ro \
  -p 8080:8080 \
  google/cadvisor:latest
```

### Типові проблеми та їх вирішення:

1. **Проблема**: Контейнер запускається з root-привілеями.
   **Рішення**: Використовуйте USER в Dockerfile для запуску процесів від непривілейованого користувача.

2. **Проблема**: Виявлені вразливості в базовому образі.
   **Рішення**: Оновіть базовий образ або використовуйте дистро з мінімальною кількістю пакетів (Alpine).

3. **Проблема**: Надто великі права для контейнера.
   **Рішення**: Запускайте контейнери з мінімально необхідними capabilities:
    ```bash
    docker run --cap-drop ALL --cap-add NET_BIND_SERVICE my-image
    ```

## Найкращі практики

### Для оптимізації об'ємів і мереж:

1. **Використовуйте іменовані об'єми** замість bind mounts для даних, які повинні зберігатися.
2. **Регулярно виконуйте команду `docker volume prune`** для видалення невикористовуваних об'ємів.
3. **Створюйте окремі мережі для різних груп сервісів** для ізоляції.
4. **Використовуйте network aliases** для зручного DNS-резолвінга між контейнерами.
5. **Документуйте всі об'єми та мережі** для полегшення розуміння архітектури.

### Для зменшення розміру образів:

1. **Починайте з найменшого можливого базового образу**, який задовольняє ваші потреби.
2. **Використовуйте багатоетапні збірки** для відділення процесу збірки від запуску.
3. **Об'єднуйте команди RUN** для зменшення кількості шарів.
4. **Ретельно налаштовуйте .dockerignore** для виключення непотрібних файлів.
5. **Використовуйте конкретні версії тегів** для базових образів замість `latest`.

### Для безпеки контейнерів:

1. **Ніколи не запускайте контейнери з опцією `--privileged`** без крайньої необхідності.
2. **Регулярно оновлюйте базові образи** для отримання виправлень безпеки.
3. **Сканування образів на вразливості** має бути частиною CI/CD pipeline.
4. **Використовуйте непривілейованих користувачів** для запуску процесів у контейнерах.
5. **Застосовуйте принцип найменших привілеїв** для всіх контейнерів.
6. **Ізолюйте критичні сервіси** у внутрішніх мережах без доступу до інтернету.
7. **Впровадьте моніторинг і логування** для всіх контейнерів у продакшн середовищі.
