# Розділ 1: Замикання (Closures)

## Вступ

**Замикання (Closure)** — це фундаментальний механізм у JavaScript, який дозволяє функції "запам'ятовувати" та мати доступ до свого лексичного оточення (lexical scope) навіть після того, як її виконання завершилося. Простими словами, функція несе із собою "рюкзак" зі змінними, які були доступні в момент її створення.

Це не просто синтаксична особливість, а ключовий елемент, на якому побудовано безліч патернів: модулі, приватні змінні, каррінг (currying), та значна частина функціонального програмування в JS.

## Семантика та принцип роботи

Щоб зрозуміти замикання, потрібно спочатку зрозуміти **лексичне оточення (Lexical Environment)**. Коли викликається функція, JavaScript-рушій створює для неї спеціальний внутрішній об'єкт — лексичне оточення. Воно складається з двох частин:

1.  **Environment Record**: Об'єкт, де зберігаються всі локальні змінні та параметри функції як його властивості.
2.  **Reference to the outer lexical environment**: Посилання на зовнішнє лексичне оточення — те, в якому функція була *оголошена*, а не *викликана*.

Коли функція повертає іншу функцію, ця внутрішня функція зберігає посилання на лексичне оточення, в якому вона була створена. Це і є замикання. Навіть коли зовнішня функція завершила свою роботу і її стек виклику (call stack) очищено, її лексичне оточення залишається в пам'яті, доки на нього посилається внутрішня функція.

Візуалізуємо цей процес:

```mermaid
graph TD
    A[Глобальне лексичне оточення] --> B{Лексичне оточення `createCounter()`};
    B -- `counter` є тут --> C{Лексичне оточення `increment()`};
    C -- зберігає посилання --> B;

    subgraph "Global Scope"
        A
        D[const myCounter = createCounter()]
    end

    subgraph "createCounter() Scope"
        B
        E[let counter = 0]
    end

    subgraph "increment() Scope"
        C
        F[counter++]
    end

    style B fill:#f9f,stroke:#333,stroke-width:2px
    style C fill:#ccf,stroke:#333,stroke-width:2px
```

На схемі видно, що `increment()` має власне оточення, але також має "приховане" посилання на оточення `createCounter()`, що дозволяє їй отримувати доступ до змінної `counter`.

## Базовий синтаксис

Класичний приклад — функція-лічильник.

```javascript
function createCounter() {
  let counter = 0; // Ця змінна "замикається"

  // Ця функція створюється в лексичному оточенні createCounter()
  function increment() {
    counter++;
    console.log(counter);
  }

  return increment; // Повертаємо функцію, а не її результат
}

const myCounter = createCounter(); // myCounter тепер є функцією increment

// Навіть після того, як createCounter() завершилась,
// myCounter все ще має доступ до змінної `counter`.
myCounter(); // Виведе: 1
myCounter(); // Виведе: 2
myCounter(); // Виведе: 3

// Створимо інший незалежний лічильник
const anotherCounter = createCounter();
anotherCounter(); // Виведе: 1. Він має власне замикання.
```

## Практичні кейси

Замикання — це не теоретична абстракція. Вони використовуються щодня.

1.  **Інкапсуляція та приватні змінні (Data Encapsulation & Private Variables)**: До появи класів в ES6, замикання були основним способом створення приватних змінних.

    ```javascript
    function createPerson(name) {
      let _age = 0; // Приватна змінна

      function getAge() {
        return _age;
      }

      function haveBirthday() {
        _age++;
        console.log(`Happy birthday! ${name} is now ${_age}`);
      }

      return { name, getAge, haveBirthday };
    }

    const john = createPerson('John');
    john.haveBirthday(); // "Happy birthday! John is now 1"
    console.log(john._age); // undefined. Прямого доступу немає.
    console.log(john.getAge()); // 1. Доступ через публічний метод.
    ```

2.  **Фабричні функції та Модулі (Factory Functions & Modules)**: Патерн "Модуль" використовує замикання для створення публічного API, приховуючи деталі реалізації.

    ```javascript
    const Calculator = (function() {
      // Цей код виконується один раз (завдяки IIFE)
      let memory = 0; // Приватна змінна стану

      function add(a, b) {
        const result = a + b;
        memory = result;
        return result;
      }

      function getLastResult() {
        return memory;
      }

      // Публічний API
      return {
        add,
        getLastResult,
      };
    })(); // Immediately Invoked Function Expression (IIFE)

    console.log(Calculator.add(5, 10)); // 15
    console.log(Calculator.getLastResult()); // 15
    console.log(Calculator.memory); // undefined
    ```

3.  **Обробники подій (Event Handlers)**: Часто потрібно передати додаткові дані в обробник події.

    ```javascript
    function createAlert(message) {
      // Ця функція замикає `message`
      return function() {
        alert(message);
      };
    }

    const helloButton = document.getElementById('helloBtn');
    // createAlert('Hello, World!') повертає обробник, який пам'ятає 'Hello, World!'
    helloButton.addEventListener('click', createAlert('Hello, World!'));
    ```

## Глибокі концепти

*   **Ланцюжок областей видимості (Scope Chain)**: Коли функція шукає змінну, вона спочатку перевіряє власне лексичне оточення. Якщо не знаходить, вона йде до зовнішнього оточення (на яке має посилання), потім до його зовнішнього, і так далі, аж до глобального об'єкта. Замикання гарантує, що цей ланцюжок не розривається.

*   **Управління пам'яттю (Memory Management)**: Змінні, захоплені замиканням, не видаляються збирачем сміття (Garbage Collector) доти, доки існує хоча б одна функція, що на них посилається. Це може призвести до витоків пам'яті (memory leaks), якщо посилання на замикаючу функцію зберігається довше, ніж потрібно (наприклад, глобальний обробник подій, який ніколи не видаляється).

*   **Дебагінг (Debugging)**: Сучасні інструменти розробника в браузерах дозволяють інспектувати замикання. У вкладці "Sources", поставивши breakpoint всередині замкненої функції, ви можете побачити секцію `Scope`, де буде окремий блок `Closure`, що містить усі захоплені змінні та їхні поточні значення.

## Best Practices

1.  **Використовуйте для інкапсуляції**: Це один з найкращих способів приховати стан і логіку, надаючи лише необхідний публічний інтерфейс.
2.  **Будьте обережні в циклах**: Завжди використовуйте `let` або `const` для оголошення лічильників у циклах, щоб уникнути поширеної помилки з `var`, коли всі ітерації замикають одне й те саме значення змінної.
3.  **Усвідомлюйте вплив на пам'ять**: Якщо ви створюєте багато довгоживучих об'єктів із замиканнями (наприклад, у великих односторінкових додатках), переконайтеся, що на них не залишається непотрібних посилань.

## Антипатерни

1.  **Замикання в циклах з `var` (Класична помилка)**

    ```javascript
    // Антипатерн
    for (var i = 1; i <= 3; i++) {
      setTimeout(function() {
        console.log(i); // Завжди виведе 4, 4, 4
      }, 10);
    }
    ```
    *Чому це погано?* `var` має функціональну, а не блокову область видимості. Всі три анонімні функції замикають *одну й ту саму* змінну `i`. На момент їх виконання цикл вже завершився, і `i` дорівнює 4.

    *Як виправити?* Використовувати `let`, яка має блокову область видимості. На кожній ітерації створюється нове лексичне оточення і нова змінна `i`.
    ```javascript
    // Правильно
    for (let i = 1; i <= 3; i++) {
      setTimeout(function() {
        console.log(i); // Виведе 1, 2, 3
      }, 10);
    }
    ```

2.  **Непотрібне створення замикань**: Створення функцій всередині інших функцій без потреби може призвести до зайвого споживання пам'яті та ускладнення коду. Якщо функція не використовує змінні з зовнішнього скоупу, її можна винести назовні.

## Взаємозв’язки

*   **Функції вищого порядку (Higher-Order Functions)**: Замикання є невід'ємною частиною функцій, які повертають інші функції (фабрики, каррінг).
*   **Асинхронність (Asynchronicity)**: Коли ви передаєте колбек (callback) у `setTimeout`, `fetch` або `addEventListener`, ви майже завжди використовуєте замикання, щоб зберегти контекст (змінні, стан) для майбутнього виконання.
*   **Функціональне програмування (Functional Programming)**: Концепти як каррінг (currying) та композиція функцій (function composition) сильно покладаються на замикання для передачі стану між викликами.
*   **React/Vue**: У функціональних компонентах React хуки (`useState`, `useEffect`) використовують замикання для збереження стану (`state`) між рендерами. Аналогічно, `ref` та `reactive` у Vue 3 Composition API працюють завдяки замиканням.

---

**Наступна тема:** [Прототипи та прототипне наслідування (Prototypes and Prototypal Inheritance)](02-prototypes.md)
